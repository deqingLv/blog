
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"职场里，很多人一开始只关注“正确地做事”：需求排期要准时，文档要规范，汇报要逻辑清晰，执行要高效无误。这当然重要，它让你显得“靠谱”，是职场生存的基础。但如果只停留在这一层，你做得再好，也只是一个高效的执行者。\n真正拉开差距的，是“做正确的事”。它关心的是：我们为什么要做这件事？它真的有价值吗？有没有更值得投入的方向？很多团队并不是“做得不够好”，而是一开始就选错了要做的事，于是所有努力都在错误的方向上内卷。\n正确地做事，本质上是把“既定问题”解决好；做正确的事，则是先问一句：“这个问题值不值得解决？”前者偏向执行力，后者偏向判断力和决策力。随着职级提升，公司对你的期待也会从前者逐渐转向后者。\n在具体工作中，可以刻意练习这两层能力：\n先问一个“为什么”：接到任务时，不急着拆解和排期，先理解业务目标——这件事成功了，谁会受益？指标怎样变化？ 再设计“怎么做得更好”：在方向确定之后，再回到执行细节，思考有没有更高效、更稳妥的实现方式。 当你既能把事做对，又敢于、也有能力去选择对的事，你的角色就会从“被安排任务的人”，慢慢变成“定义任务的人”。这往往也是从“打工者心态”走向“负责人心态”的真正分界线。\n怎么把事做对？ “把事做对”更偏向工程思维：流程清晰、工具合适、结果可复用。一个简单的做法，是为重要工作建立可复制的模板和 SOP。可以参考我的github库 tl-sops-md，是用来沉淀工作中常用任务的模板和SOP的。\n这代表着一种态度：我要用结构化的方式来做事，而不是每次从零开始拍脑袋。这类“把事情做对”的习惯，会极大降低出错率，也让新人更容易接手你的工作。\n怎么做正确的事？ 做正确的事，更偏向判断和选择。可以用一个非常简单的小方法论：\n三问法\n这件事的目标是什么？（不达成会怎样？） 哪些指标能证明它值得做？（业务、用户、效率、安全等） 它的机会成本是什么？（因此放弃了什么其他事情？） 分层看优先级\n今天/本周：解决“最痛的”问题（短期收益） 本季度：推进 1–2 件“真正改变曲线”的事（中长期复利） 定期回顾\n每月/每季度回顾：哪些事其实不值得做？哪些事应该早点做？通过不断纠偏，让你选择的事情，越来越“对”。\n当你习惯用 SOP 和工具来把事做对，再叠加一套简单可执行的**“选择正确之事”的方法论**，你的职场成长速度，会明显和别人不一样。\n","date":1767085120,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1767109275,"objectID":"37475fd600add90324157e24bd7724eb","permalink":"https://deqinglv.github.io/blog/post/doing-things-right-and-doing-right-thins/","publishdate":"2025-12-30T16:58:40+08:00","relpermalink":"/blog/post/doing-things-right-and-doing-right-thins/","section":"post","summary":"聊聊职场中如何既把事情做对，又学会选择那些真正值得做的事，从执行者走向负责人。","tags":null,"title":"正确的做事 \u0026 做正确的事","type":"post"},{"authors":null,"categories":null,"content":"LangChain 1.0 React Agent Demo：构建智能推理代理 LangChain 1.0 版本带来了许多重要的改进和新特性，其中 React（Reasoning and Acting）模式的 Agent 是一个强大的功能。本文将带你从零开始，使用 Python 构建一个完整的 React Agent Demo。\n什么是 React Agent？ React（Reasoning and Acting）是一种结合了推理（Reasoning）和行动（Acting）的 Agent 模式。Agent 会：\n推理（Reasoning）：分析问题，思考需要采取什么行动 行动（Acting）：调用工具执行具体操作 观察（Observing）：观察工具执行的结果 循环：基于观察结果继续推理，直到完成任务 这种模式让 Agent 能够处理复杂的多步骤任务，通过工具调用来获取信息、执行操作，最终给出答案。\n环境准备 1. Python 版本要求 重要：LangChain 1.0 要求 Python 版本 ≥ 3.10。Python 3.9 及以下版本不再支持。\n检查你的 Python 版本：\npython --version # 或 python3 --version 如果版本低于 3.10，请先升级 Python 版本。\n2. 安装依赖 安装必要的 Python 包：\npip install langchain\u0026gt;=1.0.0 pip install langchain-openai pip install langchain-community pip install langchain-experimental pip install langchainhub 3. 配置环境变量 设置你的 DeepSeek API 密钥：\nexport DEEPSEEK_API_KEY=\u0026#34;your-deepseek-api-key-here\u0026#34; 如果需要使用搜索工具，还需要设置 Tavily API Key：\nexport TAVILY_API_KEY=\u0026#34;your-tavily-api-key-here\u0026#34; 完整代码实现 基础版本：简单的 React Agent 让我们先创建一个基础的 React Agent：\nimport os from langchain_openai import ChatOpenAI from langchain.agents import create_react_agent, AgentExecutor from langchain import hub from langchain_community.tools import DuckDuckGoSearchRun # 初始化语言模型（使用 DeepSeek） llm = ChatOpenAI( model=\u0026#34;deepseek-chat\u0026#34;, temperature=0, api_key=os.getenv(\u0026#34;DEEPSEEK_API_KEY\u0026#34;), base_url=\u0026#34;https://api.deepseek.com/v1\u0026#34; ) # 定义工具 tools = [ DuckDuckGoSearchRun() ] # 从 LangChain Hub 加载 React prompt prompt = hub.pull(\u0026#34;hwchase17/react\u0026#34;) # 创建 React Agent agent = create_react_agent(llm, tools, prompt) # 创建 Agent 执行器 agent_executor = AgentExecutor( agent=agent, tools=tools, verbose=True, handle_parsing_errors=True ) # 运行 Agent if __name__ == \u0026#34;__main__\u0026#34;: response = agent_executor.invoke({ \u0026#34;input\u0026#34;: \u0026#34;什么是 LangChain？它有哪些主要特性？\u0026#34; }) print(\u0026#34;\\n最终答案：\u0026#34;) print(response[\u0026#34;output\u0026#34;]) 进阶版本：多工具 React Agent 让我们创建一个更强大的版本，包含多个工具：\nimport os from langchain_openai import ChatOpenAI from langchain.agents import create_react_agent, AgentExecutor from langchain import hub from langchain_community.tools import DuckDuckGoSearchRun from langchain_experimental.tools import PythonREPLTool from langchain_core.tools import Tool from datetime import datetime # 初始化语言模型（使用 DeepSeek） llm = ChatOpenAI( model=\u0026#34;deepseek-chat\u0026#34;, temperature=0, api_key=os.getenv(\u0026#34;DEEPSEEK_API_KEY\u0026#34;), base_url=\u0026#34;https://api.deepseek.com/v1\u0026#34; ) # 定义自定义工具：获取当前时间 def get_current_time(query: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;获取当前日期和时间\u0026#34;\u0026#34;\u0026#34; return f\u0026#34;当前时间：{datetime.now().strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;)}\u0026#34; # 定义自定义工具：计算器 def calculator(expression: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;执行数学计算\u0026#34;\u0026#34;\u0026#34; try: result = eval(expression) return f\u0026#34;计算结果：{result}\u0026#34; except Exception as e: return f\u0026#34;计算错误：{str(e)}\u0026#34; # 创建工具列表 tools = [ DuckDuckGoSearchRun(name=\u0026#34;search\u0026#34;, description=\u0026#34;搜索互联网获取最新信息\u0026#34;), PythonREPLTool(name=\u0026#34;python_repl\u0026#34;, description=\u0026#34;执行 Python 代码\u0026#34;), Tool( name=\u0026#34;get_time\u0026#34;, func=get_current_time, description=\u0026#34;获取当前日期和时间\u0026#34; ), Tool( name=\u0026#34;calculator\u0026#34;, func=calculator, description=\u0026#34;执行数学计算，输入数学表达式\u0026#34; ), ] # 从 LangChain Hub 加载 React prompt prompt = hub.pull(\u0026#34;hwchase17/react\u0026#34;) # 创建 React Agent agent = create_react_agent(llm, tools, prompt) # 创建 Agent 执行器 agent_executor = AgentExecutor( agent=agent, tools=tools, verbose=True, handle_parsing_errors=True, max_iterations=10, max_execution_time=60 ) def run_agent(query: str): \u0026#34;\u0026#34;\u0026#34;运行 Agent 并返回结果\u0026#34;\u0026#34;\u0026#34; try: response = agent_executor.invoke({\u0026#34;input\u0026#34;: query}) return response[\u0026#34;output\u0026#34;] except Exception as e: return f\u0026#34;执行错误：{str(e)}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: # 示例 1：搜索信息 print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;示例 1：搜索信息\u0026#34;) print(\u0026#34;=\u0026#34; * 50) result1 = run_agent(\u0026#34;LangChain 1.0 版本有哪些新特性？\u0026#34;) print(f\u0026#34;\\n结果：{result1}\\n\u0026#34;) # 示例 2：数学计算 print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;示例 2：数学计算\u0026#34;) print(\u0026#34;=\u0026#34; * 50) result2 = run_agent(\u0026#34;计算 (1234 * 5678) / 100 的结果\u0026#34;) print(f\u0026#34;\\n结果：{result2}\\n\u0026#34;) # 示例 3：Python 代码执行 print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;示例 3：Python 代码执行\u0026#34;) print(\u0026#34;=\u0026#34; * 50) result3 = run_agent(\u0026#34;使用 Python 生成一个包含 10 个随机数的列表，并计算它们的平均值\u0026#34;) print(f\u0026#34;\\n结果：{result3}\\n\u0026#34;) # 示例 4：综合任务 print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;示例 4：综合任务\u0026#34;) print(\u0026#34;=\u0026#34; * 50) result4 = run_agent(\u0026#34;今天是几号？然后搜索一下今天有什么重要的科技新闻\u0026#34;) print(f\u0026#34;\\n结果：{result4}\\n\u0026#34;) 高级版本：带记忆的 React Agent 为了让 Agent 能够记住对话历史，我们可以添加记忆功能：\nimport os from langchain_openai import ChatOpenAI from langchain.agents import create_react_agent, AgentExecutor from langchain import hub from langchain_community.tools import DuckDuckGoSearchRun from langchain_community.chat_message_histories import ChatMessageHistory from langchain_core.chat_history import BaseChatMessageHistory from langchain_core.runnables.history import RunnableWithMessageHistory # 初始化语言模型（使用 DeepSeek） llm = ChatOpenAI( model=\u0026#34;deepseek-chat\u0026#34;, temperature=0, api_key=os.getenv(\u0026#34;DEEPSEEK_API_KEY\u0026#34;), base_url=\u0026#34;https://api.deepseek.com/v1\u0026#34; ) # 定义工具 tools = [DuckDuckGoSearchRun()] # 加载 React prompt prompt = hub.pull(\u0026#34;hwchase17/react\u0026#34;) # 创建 Agent agent = create_react_agent(llm, tools, prompt) # 创建 Agent 执行器 agent_executor = AgentExecutor( agent=agent, tools=tools, verbose=True, handle_parsing_errors=True, ) # 存储对话历史的字典 store = {} def get_session_history(session_id: str) -\u0026gt; BaseChatMessageHistory: \u0026#34;\u0026#34;\u0026#34;获取或创建会话历史\u0026#34;\u0026#34;\u0026#34; if session_id not in store: …","date":1767078006,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1767084826,"objectID":"240e443781e12366175b8c5aa2945a7f","permalink":"https://deqinglv.github.io/blog/post/langchain-1-agent-demo/","publishdate":"2025-12-30T15:00:06+08:00","relpermalink":"/blog/post/langchain-1-agent-demo/","section":"post","summary":"基于 LangChain 1.0 版本，使用 Python 开发一个 React（Reasoning and Acting）模式的智能代理 demo，展示如何构建能够推理和行动的 AI Agent","tags":null,"title":"LangChain 1.0 React Agent Demo：构建智能推理代理","type":"post"},{"authors":null,"categories":null,"content":"Building a SOCKS Proxy with Shadowsocks This guide walks you through setting up a Shadowsocks proxy server on an ECS instance.\nStep 1: Set Up Your ECS Instance First, purchase an ECS instance running CentOS. I used Alibaba Cloud, which offers 200GB/month of free public network traffic with CDT.\nStep 2: Install and Configure Shadowsocks Log into your ECS instance as root and run the following commands:\nyum install -y docker docker run -d \\ --name ss-server \\ -p 8388:8388 \\ -e PASSWORD=${use-your-password} \\ -e METHOD=aes-256-cfb \\ shadowsocks/shadowsocks-libev Note: Replace ${use-your-password} with your desired password.\nStep 3: Connect from Your Client Finally, use ShadowsocksX-NG-R8 (or any compatible Shadowsocks client) to connect from your laptop or desktop computer.\n","date":1766238585,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1766241685,"objectID":"420040b8d3336fab23fb38362e5ffef7","permalink":"https://deqinglv.github.io/blog/post/my-socks-proxy/","publishdate":"2025-12-20T21:49:45+08:00","relpermalink":"/blog/post/my-socks-proxy/","section":"post","summary":"build ss socks proxy","tags":null,"title":"Building a SOCKS Proxy with Shadowsocks","type":"post"},{"authors":null,"categories":null,"content":"什么是记忆 在AI智能体的语境下，记忆（Memory） 是指智能体存储、组织和检索过往交互信息的能力。它使得智能体能够：\n记住用户的偏好和历史对话 理解上下文和维持连贯性 从过往经验中学习和改进 构建长期的用户关系 记忆是智能体从简单的\u0026#34;问答机器\u0026#34;进化为真正\u0026#34;智能助手\u0026#34;的关键能力。没有记忆，每次对话都是全新的开始；有了记忆，智能体才能真正理解\u0026#34;你\u0026#34;。\n名词解释 短期记忆（Short-term Memory） 也称为工作记忆或上下文窗口记忆，指智能体在当前会话中保持的临时信息。类似于人类的工作记忆，容量有限但访问速度快。在技术实现上，通常对应LLM的上下文窗口（Context Window）。\n长期记忆（Long-term Memory） 指智能体持久化存储的信息，可以跨会话保持。包括用户画像、历史对话、知识积累等。类似于人类的长期记忆系统，容量大但需要检索机制。\n情景记忆（Episodic Memory） 记录具体事件和经历的记忆，如\u0026#34;用户在上周三询问过Python异步编程问题\u0026#34;。它保留了时间、地点、情境等上下文信息。\n语义记忆（Semantic Memory） 存储抽象知识和概念的记忆，如\u0026#34;用户偏好使用Python进行开发\u0026#34;、“用户的代码风格倾向于简洁”。它是从情景记忆中提炼出的模式化知识。\n程序记忆（Procedural Memory） 关于\u0026#34;如何做\u0026#34;的记忆，存储操作流程和技能，如\u0026#34;用户解决问题的典型工作流\u0026#34;、“用户常用的代码重构步骤”。\n记忆与知识的关系 记忆和知识是两个相关但不同的概念：\n知识（Knowledge） 是静态的、通用的信息体系：\n来源于训练数据、知识库、文档等 对所有用户一致 相对固定，更新频率低 例如：Python语法规则、算法原理、API文档 记忆（Memory） 是动态的、个性化的信息积累：\n来源于与特定用户的交互历史 因用户而异 持续更新和演化 例如：用户的编程习惯、项目上下文、历史决策 两者的关系可以这样理解：\n知识是共性，记忆是个性 知识是\u0026#34;what\u0026#34;，记忆是\u0026#34;who + when + why\u0026#34; 知识提供能力，记忆提供个性化 在智能体系统中，知识构成基础能力，而记忆让智能体能够针对每个用户提供定制化服务。最理想的状态是：通过记忆来检索和应用知识，用知识来理解和组织记忆。\n记忆与RAG的关系 RAG（Retrieval-Augmented Generation，检索增强生成） 是一种通过外部知识检索来增强LLM生成能力的技术模式。记忆系统可以看作是RAG的一种特殊应用，但两者有重要区别：\nRAG的特点 主要面向静态知识库（文档、FAQ、产品手册等） 检索的是通用知识，对所有用户一致 侧重于\u0026#34;知道什么\u0026#34;（What to know） 更新频率低，以天/周为单位 记忆系统的特点 面向动态交互历史和用户数据 存储的是个性化信息，因用户而异 侧重于\u0026#34;记住谁\u0026#34;（Who to remember） 持续实时更新，每次交互都可能产生新记忆 两者的融合 在现代智能体架构中，记忆和RAG常常协同工作：\n用户查询 ↓ ├─→ 记忆检索：查找用户历史偏好、上下文 ├─→ 知识检索（RAG）：查找相关文档、知识库 ↓ 融合上下文 ↓ LLM生成回答 ↓ 更新记忆 实践中的最佳模式：\n用记忆系统存储\u0026#34;这个用户是谁、做过什么、喜欢什么\u0026#34; 用RAG系统检索\u0026#34;这个领域的知识是什么\u0026#34; 将两者结合，实现\u0026#34;用知识服务这个特定用户\u0026#34; 智能体记忆的发展历程 智能体记忆技术的演进反映了AI从无状态工具向有状态伙伴的转变。\n第一阶段：无记忆时代（2020年以前） 早期的对话AI系统基本没有记忆能力：\n特征：每次对话都是独立的，无法关联历史信息 技术：基于规则的对话系统、简单的seq2seq模型 局限：无法维持多轮对话的连贯性，用户体验差 代表：早期的聊天机器人、客服机器人 第二阶段：会话级记忆（2020-2022） GPT-3等大模型的出现带来了上下文窗口的概念：\n特征：在单次会话内可以记住之前的对话内容 技术：Transformer的自注意力机制，上下文窗口（2K-4K tokens） 能力：支持多轮对话，理解会话内的指代关系 局限： 会话结束后信息丢失 上下 文窗口有限，长对话会遗忘早期内容 无法跨会话记忆用户信息 代表：ChatGPT早期版本（2022年底发布时） 第三阶段：基础长期记忆（2023） 随着应用需求增长，开始出现跨会话的记忆能力：\n特征：可以记住不同会话之间的信息 技术方案： 对话历史持久化存储 基于向量数据库的检索（Vector DB + Embedding） 简单的摘要和压缩机制 能力： 记住用户基本偏好 检索历史对话片段 维持跨会话的上下文连续性 局限： 记忆主要是\u0026#34;存储-检索\u0026#34;模式，缺乏理解和提炼 记忆质量依赖检索准确性 没有记忆优先级和遗忘机制 代表：ChatGPT插件生态、LangChain的Memory模块 第四阶段：结构化智能记忆（2024-至今） 当前正在发展的阶段，记忆系统变得更加智能和结构化：\n特征：记忆不再是简单存储，而是智能化的信息管理系统 技术突破： 分层记忆架构：短期/长期/语义/情景记忆分离 主动记忆管理：智能体自主决定记什么、忘什么 记忆图谱：用知识图谱组织记忆，建立关联关系 记忆蒸馏：从大量交互中提取核心认知 个性化索引：基于用户画像优化检索策略 能力升级： 从海量历史中精准提取相关信息 理解记忆的重要性并分配优先级 自动总结和更新用户画像 检测记忆冲突并主动确认 支持记忆的演化和版本管理 代表产品： ChatGPT Memory功能（2024年推出） Cursor等AI编程助手的项目记忆 各类AI Agent框架（AutoGPT、LangGraph等） 第五阶段：未来展望 - 认知级记忆（探索中） 下一代记忆系统可能具备类人的认知特性：\n预期特征： 情感记忆：记住交互中的情感色彩和用户情绪模式 隐式学习：从行为模式中自动学习，无需显式告知 联想记忆：基于关联性主动回忆相关经历 遗忘曲线：模拟人类遗忘规律，优化存储效率 记忆重构：根据新信息更新和重组已有记忆 跨模态记忆：整合文本、图像、语音等多模态信息 技术方向： 神经符号结合（Neural-Symbolic AI） 持续学习（Continual Learning） 元学习（Meta-Learning） 记忆增强神经网络（Memory-Augmented Neural Networks） 智能体记忆的实现方案 整体架构 一个完整的智能体记忆系统通常包含以下核心模块：\n┌─────────────────────────────────────────┐ │ 用户交互层 │ └──────────────┬──────────────────────────┘ ↓ ┌─────────────────────────────────────────┐ │ 记忆写入模块（Memory Writer） │ │ - 信息提取 │ │ - 重要性评估 │ │ - 记忆分类 │ └──────────────┬──────────────────────────┘ ↓ ┌─────────────────────────────────────────┐ │ 记忆存储层（Memory Storage） │ │ ├─ 短期记忆：上下文窗口/会话缓存 │ │ ├─ 工作记忆：当前任务相关信息 │ │ ├─ 长期记忆：向量数据库/图数据库 │ │ └─ 结构化存储：用户画像/实体关系 │ └──────────────┬──────────────────────────┘ ↓ ┌─────────────────────────────────────────┐ │ 记忆检索模块（Memory Retriever） │ │ - 语义检索 │ │ - 时间过滤 │ │ - 相关性排序 │ └──────────────┬──────────────────────────┘ ↓ ┌─────────────────────────────────────────┐ │ 记忆整合模块（Memory Integration） │ │ - 上下文融合 │ │ - 冲突解决 │ │ - 摘要生成 │ └──────────────┬──────────────────────────┘ ↓ ┌─────────────────────────────────────────┐ │ LLM推理层 │ └─────────────────────────────────────────┘ 核心实现方案 1. 短期记忆实现 方案A：滑动窗口策略\nclass ShortTermMemory: def __init__(self, max_tokens=4000): self.messages = [] self.max_tokens = max_tokens def add(self, message): self.messages.append(message) # 超出限制时移除最旧的消息 while self.count_tokens() \u0026gt; self.max_tokens: self.messages.pop(0) 方案B：重要性保留策略\n保留系统提示词和最近N条消息 对中间历史进行摘要压缩 保留标记为\u0026#34;重要\u0026#34;的关键节点 2. 长期记忆实现 方案A：向量数据库方案（主流）\n技术栈：\n嵌入模型：OpenAI text-embedding-3、BGE、BERT等 向量数据库：Pinecone、Weaviate、Qdrant、Milvus、Chroma 检索策略：语义相似度检索 + 元数据过滤 实现流程：\n# 1. 存储记忆 def store_memory(text, metadata): # 生成向量嵌入 embedding = embedding_model.encode(text) # 存储到向量数据库 vector_db.insert( vector=embedding, metadata={ \u0026#34;text\u0026#34;: text, \u0026#34;timestamp\u0026#34;: datetime.now(), \u0026#34;user_id\u0026#34;: metadata[\u0026#34;user_id\u0026#34;], \u0026#34;importance\u0026#34;: calculate_importance(text), \u0026#34;category\u0026#34;: classify_memory(text) } ) # 2. 检索记忆 def retrieve_memory(query, user_id, top_k=5): query_embedding = embedding_model.encode(query) results = vector_db.search( vector=query_embedding, filter={\u0026#34;user_id\u0026#34;: user_id}, top_k=top_k ) return results 方案B：图数据库方案（适合复杂关系）\n技术栈：Neo4j、Amazon Neptune、JanusGraph\n优势：\n能表达实体间的复杂关系 支持图遍历查询 适合构建用户知识图谱 示例结构：\n(User)-[:PREFERS]-\u0026gt;(Technology) (User)-[:WORKED_ON]-\u0026gt;(Project) (Project)-[:USES]-\u0026gt;(Technology) (User)-[:ASKED_ABOUT]-\u0026gt;(Concept)-[:RELATES_TO]-\u0026gt;(Technology) 方案C：混合方案（推荐）\n结合向量检索和结构化存储：\n向量数据库：存储对话历史、经验片段（语义检索） 关系数据库：存储用户画像、偏好设置（精确查询） 图数据库：存储知识关联、任务依赖（关系推理） 3. 记忆写入策略 智能过滤机制：\n不是所有信息都值得记忆，需要评估重要性：\ndef should_memorize(content, …","date":1766234780,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1766235419,"objectID":"235219499edf69b2963a0708fc88bb2e","permalink":"https://deqinglv.github.io/blog/post/memory-of-ai-agent/","publishdate":"2025-12-20T20:46:20+08:00","relpermalink":"/blog/post/memory-of-ai-agent/","section":"post","summary":"深入探讨AI智能体记忆系统的核心概念、技术实现与发展历程。从记忆的定义与分类出发，系统介绍短期记忆、长期记忆、情景记忆等不同类型，分析记忆与知识、RAG的关系。详细阐述记忆系统从无记忆时代到认知级记忆的五个发展阶段。探讨记忆共享的技术挑战与解决方案，并展望AI分身作为数字延伸的未来可能性。","tags":null,"title":"AI智能体记忆系统全解析：从工具到分身的演进之路","type":"post"},{"authors":null,"categories":null,"content":"AI Agent 认知变化：从工具到伙伴的演进\n引言 AI Agent（AI 智能体）正在经历一场认知革命。从最初的简单规则系统，到如今的基于大语言模型的智能代理，AI Agent 的认知能力发生了质的飞跃。同时，我们对 AI Agent 的认知也在不断变化——从\u0026#34;工具\u0026#34;到\u0026#34;助手\u0026#34;，再到\u0026#34;伙伴\u0026#34;。\nAI Agent 认知能力的演进 第一阶段：规则驱动的\u0026#34;机械\u0026#34;认知 早期的 AI Agent 基于预定义的规则和逻辑，其\u0026#34;认知\u0026#34;过程是线性的、可预测的。\n特点 严格遵循预设规则 无法处理规则外的情况 缺乏学习和适应能力 认知边界清晰且固定 典型应用 专家系统 简单的聊天机器人 自动化脚本 第二阶段：统计学习的\u0026#34;模式识别\u0026#34;认知 机器学习时代，AI Agent 开始通过数据学习模式，认知能力有了显著提升。\n特点 能够识别数据中的模式 在训练数据范围内表现良好 泛化能力有限 缺乏真正的\u0026#34;理解\u0026#34; 典型应用 图像识别系统 推荐系统 语音助手（早期版本） 第三阶段：大语言模型的\u0026#34;理解\u0026#34;认知 基于 Transformer 架构的大语言模型（LLM）带来了认知能力的突破。\n特点 理解自然语言语义 具备推理和逻辑能力 可以处理复杂任务 具备一定的创造能力 典型应用 ChatGPT Claude GitHub Copilot 第四阶段：多模态 Agent 的\u0026#34;综合\u0026#34;认知 当前阶段，AI Agent 正在整合多种感知能力，形成更全面的认知。\n特点 多模态理解（文本、图像、音频、视频） 工具使用能力（Tool Use） 长期记忆和上下文管理 自主规划和执行 典型应用 GPT-4 Vision Claude with Code Interpreter AutoGPT LangChain Agents 我们对 AI Agent 认知的变化 从\u0026#34;工具\u0026#34;到\u0026#34;助手\u0026#34; 工具阶段 最初，我们将 AI Agent 视为简单的工具：\n定位: 执行特定任务的程序 期望: 准确、快速、可靠 交互: 命令式、单向 关系: 使用与被使用 助手阶段 随着 AI 能力提升，我们开始将其视为助手：\n定位: 能够理解意图的智能助手 期望: 理解上下文、提供建议 交互: 对话式、双向 关系: 协作关系 从\u0026#34;助手\u0026#34;到\u0026#34;伙伴\u0026#34; 伙伴阶段 如今，AI Agent 正在成为我们的智能伙伴：\n定位: 具备自主性和创造力的智能体 期望: 主动思考、创新解决方案 交互: 深度对话、共同探索 关系: 伙伴关系、共同成长 AI Agent 认知能力的关键突破 1. 上下文理解能力 现代 AI Agent 能够：\n理解长文本上下文 跟踪对话历史 维护多轮对话的连贯性 理解隐含意图和情感 2. 推理和规划能力 AI Agent 现在可以：\n进行逻辑推理 制定多步骤计划 处理复杂问题分解 动态调整策略 3. 工具使用能力 AI Agent 学会了：\n调用外部 API 使用代码解释器 操作文件系统 整合多种工具完成任务 4. 学习和适应能力 AI Agent 具备：\n从示例中学习（Few-shot Learning） 从反馈中改进（RLHF） 适应新领域（Fine-tuning） 持续学习能力 AI Agent 认知的局限性 尽管 AI Agent 的认知能力有了巨大提升，但仍存在局限：\n1. 缺乏真正的\u0026#34;理解\u0026#34; 基于统计模式而非真正的语义理解 可能出现\u0026#34;幻觉\u0026#34;（Hallucination） 无法真正\u0026#34;理解\u0026#34;概念的本质 2. 缺乏世界模型 没有对物理世界的真实感知 缺乏常识推理 无法处理动态变化的环境 3. 缺乏长期一致性 记忆能力有限 难以保持长期一致性 可能在不同对话中给出矛盾答案 4. 缺乏真正的自主性 依赖人类提供的目标和约束 无法自主设定目标 缺乏真正的\u0026#34;意图\u0026#34; 未来展望：认知的下一步 1. 具身智能（Embodied AI） AI Agent 将拥有：\n物理世界的感知能力 与环境的实时交互 具身认知能力 2. 持续学习（Continual Learning） AI Agent 将能够：\n持续从新数据中学习 避免灾难性遗忘 适应不断变化的环境 3. 多智能体协作 多个 AI Agent 将：\n协作解决复杂问题 形成智能体社会 产生集体智慧 4. 元认知能力 AI Agent 将具备：\n对自身认知过程的认知 自我反思和评估能力 主动学习和改进 对开发者的启示 1. 理解 AI Agent 的能力边界 了解当前 AI 的能力和局限 设计合理的任务和期望 建立有效的错误处理机制 2. 设计更好的交互方式 利用 AI 的理解能力设计自然交互 提供清晰的上下文和约束 建立反馈循环 3. 构建可靠的 AI 系统 实现验证和检查机制 处理不确定性 确保系统的可控性 4. 持续学习和适应 关注 AI 技术的最新发展 及时更新对 AI 能力的认知 调整开发策略和方法 总结 AI Agent 的认知能力正在快速发展，从简单的规则系统到具备理解、推理、规划能力的智能体。同时，我们对 AI Agent 的认知也在不断变化，从\u0026#34;工具\u0026#34;到\u0026#34;助手\u0026#34;再到\u0026#34;伙伴\u0026#34;。\n这种认知变化不仅反映了技术的进步，也反映了我们对 AI 本质理解的深化。未来，随着 AI Agent 认知能力的进一步提升，我们与 AI 的关系将继续演进，可能达到更深层次的协作和伙伴关系。\n但我们也需要保持清醒的认知：AI Agent 虽然强大，但仍存在局限。理解这些局限，合理设计和使用 AI Agent，才能真正发挥其价值，推动人机协作的发展。\n","date":1766073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1766152886,"objectID":"488d174c004825e1ce786c364786086a","permalink":"https://deqinglv.github.io/blog/post/ai-agent-cognitive-evolution/","publishdate":"2025-12-19T00:00:00+08:00","relpermalink":"/blog/post/ai-agent-cognitive-evolution/","section":"post","summary":"探讨 AI Agent 认知能力的发展历程，以及我们对 AI Agent 认知的变化：从简单的工具到智能伙伴的转变","tags":null,"title":"AI Agent 认知变化：从工具到伙伴的演进","type":"post"},{"authors":null,"categories":null,"content":"Git awesome tips\nvi ~/.gitconfig add alias\n[alias] st = status br = branch co = checkout cm = commit -m aa = add . amend = commit --amend --reuse-message=HEAD # 合并当前缓冲内容到上一次的提交并复用提交信息 uncommit = reset --soft HEAD~1 # 撤销上次提交 lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit ll = log --oneline last = log -1 HEAD --stat se = !git rev-list --all | xargs git grep -F ","date":1765808640,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1766075415,"objectID":"1f1bbc2ab3fd5af57eb4a1069dd62006","permalink":"https://deqinglv.github.io/blog/post/git-awesome-tips/","publishdate":"2025-12-15T22:24:00+08:00","relpermalink":"/blog/post/git-awesome-tips/","section":"post","summary":"some awesome tips of git","tags":null,"title":"Git awesome tips","type":"post"},{"authors":null,"categories":null,"content":"iTerm2 + zsh + oh-my-zsh The Most PowerFull Terminal on my macbook.\nInstall # Install iterm2 or go to download page: https://www.iterm2.com/downloads.html brew install --cask iterm2 # Install zsh brew install zsh # Install oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; Decorate Our iTerm2 Getting rid of the title bar Go to iTerm2 \u0026gt; Appearance \u0026gt; General \u0026gt; Theme: Dark\niTerm2 theme Go to iTerm2 \u0026gt; Preferences \u0026gt; Profiles \u0026gt; Colors Tab\nGet the iTerm color settings:\nhttps://github.com/topics/iterm2-theme\nhttps://iterm2colorschemes.com\nSnazzy.itermcolors looks goot to me\niTerm2 BackgroundIamge Go to iTerm2 -\u0026gt; Preferences -\u0026gt; Profiles -\u0026gt; window -\u0026gt; Background Image. Choose your favorite wallpaper and set Blending.\nZsh Theme: Powerlevel10k Install Powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k echo \u0026#39;source ~/powerlevel10k/powerlevel10k.zsh-theme\u0026#39; \u0026gt;\u0026gt;~/.zshrc Prompt Style use ‘Pure’\nHide Username \u0026amp; Hostname echo \u0026#39;prompt_context() {}\u0026#39; \u0026gt;\u0026gt; ~/.zshrc Manage Plugins zsh-syntax-highlighting Clone this repository in oh-my-zsh’s plugins directory:\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting Activate the plugin in ~/.zshrc:\nplugins=( [plugins...] zsh-syntax-highlighting) Note that zsh-syntax-highlighting must be the last plugin sourced.\nRestart zsh (such as by opening a new instance of your terminal emulator).\nexec zsh zsh-autosuggestions Clone this repository in oh-my-zsh’s plugins directory:\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions Activate the plugin in ~/.zshrc:\nplugins=( # other plugins... zsh-autosuggestions ) Restart zsh (such as by opening a new instance of your terminal emulator).\nexec zsh autojump brew install autojump Common Tips and Shortcuts Tips:\nSelection is copied command + d :Vertical split screen command + shift + d :Horizontal split screen command + shift + h :Open the Clipboard (Copy History) Alias My alias:\n# navigation aliases alias dev=\u0026#34;cd ~/dev/\u0026#34; alias personal=\u0026#34;cd ~/persional\u0026#34; alias work=\u0026#34;cd ~/work\u0026#34; # kubectl aliases alias k=\u0026#34;kubectl\u0026#34; alias kt=\u0026#34;sudo ktctl\u0026#34; # docker aliases alias d=\u0026#34;docker\u0026#34; ","date":1668091083,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1765555268,"objectID":"220a72382c17198d769736992136ad47","permalink":"https://deqinglv.github.io/blog/post/my-powerfull-terminal/","publishdate":"2022-11-10T22:38:03+08:00","relpermalink":"/blog/post/my-powerfull-terminal/","section":"post","summary":"iTerm2 + zsh + oh-my-zsh The Most PowerFull Terminal on my macbook","tags":null,"title":"My Powerfull Terminal","type":"post"},{"authors":null,"categories":null,"content":"基于GitHub Pages + Hugo搭建的个人博客，给大家介绍下搭建过程。\n序言 博客还是一个开发者很好的名片，不仅可以记录点滴，还能让更多人认识你了解你，为你赢来潜在的机会。 开发者另个好名片就是代码了，以GitHub上开源的代码项目最为著名，可以主导或者参与到优秀的项目中，提升知名度。 为了和代码一起，我选择GitHub-pages来搭建个人博客，由于现在钟爱Golang，所以作为Hugo作为博客搭建的工具。 下面记录下基于Hugo和GitHub-pages搭建个人博客的方法\n前提 GitHub账号： 点此创建 Hugo安装: 安装方法：macOS , Windows , Linux. 因为我使用的是macOS，所以下面的操作环境都在mac下。 mac 执行安装Hugo\nbrew install hugo 利用Hugo建博客 新增站点 选择一个存在站点的目录，我的是在 /Users/Archer/Personal/Github 目录下\n在终端（terminal）上操作，cd到存放站点的目录，新建站点，我的站点名就叫blog。\ncd /Users/Archer/Personal/Github hugo new site blog Congratulations! Your new Hugo site is created in /Users/Archer/Personal/Github/blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. cd 到新生成的目录下，通过git init初始化\ncd blog \u0026amp;\u0026amp; git init 安装主题 从主题市场选择一个喜欢的主题，快速搭建好看的站点吧。\n不同主题的使用方法也不同，我选择了一个GitHub风格的主题：github-style ,感谢MeiK的创作\n在站点目录下\n# git submodule add \u0026lt;LINK_TO_THEME_REPO\u0026gt; themes/\u0026lt;THEME_NAME\u0026gt;. 库下载地址必须是https git submodule add https://github.com/MeiK2333/github-style.git themes/github-style # echo \u0026#39;theme = \u0026#34;\u0026lt;THEME_NAME\u0026gt;\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml echo \u0026#39;theme = \u0026#34;github-style\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml config.toml像这样\ncat config.toml baseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;github-style\u0026#34; 测试站点 通过hugo启动本地服务\nhugo server 在浏览器访问 http://localhost:1313\n至此本地的个人博客站点就完成了。\n可以通过\nhugo new posts/first-post.md 发布你的第一篇博客\n利用GitHub Pages提供免费的网页服务 创建博客用的代码库 首先在GitHub建立一个空的公开库，由于之前已经在博客目录做了git init，所以可以将博客目录内容推送到GitHub仓库上\ngit remote add origin git@github.com:deqingLv/blog.git git add . git commit -m \u0026#39;init blog\u0026#39; git push --set-upstream origin master 这样一来，博客的所有内容就都在GitHub库的master分支上了。\n开启GitHub Pages服务 在GitHub的库页面上通过 Settings \u0026gt; Options \u0026gt; Github Pages\n由于GitHub Pages默认是基于Jekyll来建站的，而Hugo并不是，GitHub Pages也可以支持纯静态网站资源来提供服务。\n划重点：在GitHub Pages的源分支选择\u0026#34;master branches /docs folder\u0026#34;, 只使用/docs目录来提供网页服务。\nHugo可以通过hogo命令进行发布构建，发布结果可指定/docs目录。 修改config.toml\necho \u0026#39;publishDir = \u0026#34;docs\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml cat config.toml baseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;github-style\u0026#34; publishDir = \u0026#34;docs\u0026#34; 执行hugo 构建， 得到/docs目录，再把/docs所有内容进行提交\nhugo git add . git commit -m \u0026#39;init docs\u0026#39; git push GitHub仓库收到提交会自动构建Pages服务。在Code可以找到Environments\n通过View deployment就能访问个人博客了。 这个地址和域名还可以在GitHub Pages设置里进行修改。\n博客发布 上面配置完后，博客的写作和发布过程如下\n# 创建 hugo new posts/xxxx.md # 写博客 vim xx/xx/xxxx.md # 本地测试 hugo server # 构建 hugo # 提交到GitHub git add . git commit -m \u0026#39;xxx\u0026#39; git push # 浏览GitHub Pages，查看发布效果 下面是我的个人博客: https://deqinglv.github.io/blog\n欢迎勾搭\n","date":1592972863,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1765555268,"objectID":"ffc6c63dbfa5f2e7acb835195ca29183","permalink":"https://deqinglv.github.io/blog/post/make-blog-with-hugo-github-pages/","publishdate":"2020-06-24T12:27:43+08:00","relpermalink":"/blog/post/make-blog-with-hugo-github-pages/","section":"post","summary":"基于GitHub Pages + Hugo搭建的个人博客，给大家介绍下搭建过程","tags":null,"title":"Make blog with hugo and github-pages","type":"post"},{"authors":null,"categories":null,"content":"About me\n","date":1592970390,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1765555268,"objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://deqinglv.github.io/blog/about/","publishdate":"2020-06-24T11:46:30+08:00","relpermalink":"/blog/about/","section":"","summary":"About me\n","tags":null,"title":"About","type":"page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1766839428,"objectID":"1c196360697e828341d6908a76374bf4","permalink":"https://deqinglv.github.io/blog/posts/mac-productivity-tools/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/posts/mac-productivity-tools/","section":"posts","summary":"","tags":null,"title":"","type":"posts"}]